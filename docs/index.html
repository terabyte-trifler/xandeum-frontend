/**
 * Apply filters to pNode list
 */
function applyFilters(
  pnodes: PNode[], 
  filters?: PNodeFilters
): PNode[] {
  if (!filters) return pnodes;
  
  return pnodes.filter(node => {
    // Status filter
    if (filters.status?.length && !filters.status.includes(node.status)) {
      return false;
    }
    
    // Minimum uptime filter
    if (filters.minUptime !== undefined && 
        node.performance.uptimePercentage < filters.minUptime) {
      return false;
    }
    
    // Search filter (pubkey, name, location)
    if (filters.search) {
      const searchLower = filters.search.toLowerCase();
      const matchesPubkey = node.identity.pubkey
        .toLowerCase().includes(searchLower);
      const matchesName = node.metadata.name
        ?.toLowerCase().includes(searchLower);
      const matchesCity = node.geo?.city
        .toLowerCase().includes(searchLower);
      
      if (!matchesPubkey && !matchesName && !matchesCity) {
        return false;
      }
    }
    
    return true;
  });
}

/**
 * Apply sorting to pNode list
 */
function applySort(
  pnodes: PNode[], 
  sort?: PNodeSortOptions
): PNode[] {
  if (!sort) return pnodes;
  
  const sorted = [...pnodes];
  const multiplier = sort.order === 'asc' ? 1 : -1;
  
  sorted.sort((a, b) => {
    let comparison = 0;
    switch (sort.field) {
      case 'status':
        const statusOrder = { online: 0, syncing: 1, degraded: 2, offline: 3 };
        comparison = statusOrder[a.status] - statusOrder[b.status];
        break;
      case 'uptime':
        comparison = a.performance.uptimePercentage - b.performance.uptimePercentage;
        break;
      case 'stake':
        comparison = (a.staking.stakedXand + a.staking.delegatedXand) - 
                     (b.staking.stakedXand + b.staking.delegatedXand);
        break;
      // ... more cases
    }
    return comparison * multiplier;
  });
  
  return sorted;
}